p107
2.43:

对于整数x乘以常数M, 如果M=[(0..0)(1..1)(0..0)(1..1)(0..0)..],
对于每一组(1..1), 如果最高位为n, 最低位为m,
则x与这组1相乘的结果为
A: x<<m + x<<(m+1) + ... + x<<n;
也可以表示为
B: x<<(n+1)-x<<m

对于整数y除以一个常数N=pow(2,k), 
如果y>=0, 则值为 y>>k;
如果y<0, 则值为 (y + (1<<k)-1)>>k;

因此，对于 result = x*M + y/N;这条语句，
由编译器优化后生成的汇编代码再转成的C代码如下：
int t = x;
x <<= 5;
x -= t;
if (y<0) y += 7;
y >>= 3;

可以看出，x*M转变成了 x<<5 - x<<0, 故n+1=5, n=4, M=[11111] = 31
k=3, N = pow(2,3)=8

p108
2.44:

假设int为32为补码型整数，有符号数右移是算术右移，无符号数右移是逻辑右移。

其中:
int x = foo();
int y = bar();
unsigned ux = x;
unsigned uy = y;
对于以下的各表达式，回答两个问题：(1)对于任意的x和y值，该表达式是否为true,
(2) 当x和y取什么值时为false

A. (x > 0) || (x-1 < 0)
　　当 T=T<min>时， x-1=T<max; 故False
B. (x & 7) != 7 || (x<<29 < 0)
   左边的要求x的最低3位不能全部为1, 右边的要求第3位为1; 当x的第3位为1时，右边为真，故表达式为真；当x的第3位为0时，右边为假，但符合左边的要求（最低3位不能全部为1），故无论x为何值，表达式都为真
C. (x * x) >= 0
   由于是固定倍数，会有溢出的情况，会有正数乘以正数结果为负数的情况，故某些条件下 (x*x)<0, 例如：当x=pow(2,16)-1时，x*x=pow(2,32)+1-pow(2,17), 在32位
   的补码表示时，pow(2,32)溢出，-pow(2,17)可以用pow(2,17)取反+1获取，此时x*x的值中最高位为1,为负数。
D. x<O || -x <= 0
    x=0时显然成立;左边要求x的最高位为1;右边-x<0,即x取反+1后最高位为1, 由于左边要求最高位为1,现在只考虑右边最高位为0，此时取反+1后最高位都为1, 或者00..0取反+1后为0也符合;因此结果都为真
E. x>O || -x >= 0
    x=0显示成立; 左边要求x最高位为0; 右边-x>0, 即要求x取反+1后最高位为0, 由于左边要求最高位为0, 现只考虑右边最高位为1, 但是对于x=[100..00], 取反+1后为[011..11]+1=[100..00]<0, 此时为假。即当x=Tmin时， -x=-Tmin=Tmin<0
F. x+y == uy+ux
    表达式中含无符号数，所以左边也要转成无符号数。 在二进制上，无符号数和有符号数的加法是一样的，故都为真。
G. x*~y + uy*ux == -x
    -y = ~y+1,故 ~y=-y-1, 左边= x*(-y-1)+uy*ux = uy*ux - x*y -x, 不管是无符号数还是有符号数，在二进制层面上相乘后截短后的结果都是相同的。故 uy*ux-x*y=0, 故结果都为真


p111
2.45:

分数的二进制表示：

0.1=1/2=0.5  0.01=1/4=0.25  0.001=1/8=0.125  0.0001=1/16=0.0625  0.00001=1/32=0.03125

将分数转成二进制表示的方法是，先将分数表达成 x/pow(2,k)的形式，然后将 x 转成二进制，其小数点的位置由 k 决定，例如，25/16 中， x=25=[11001], 而16=pow(2,4), 故 25/16=1.1001

因此：

分数                       二进制值      十进制值
------                    ----------   ------------
1/8                          0.001        0.0125
3/4=1/4+1/2                  0.11         0.75
5/16=1/4+1/16                0.0101       0.3125
2+1/2+1/8+1/16=2+11/16       10.1011      2.6875
1+1/8                        1.001        1.125
5+1/2+1/4+1/8=5+7/8          101.111      5.875
3+1/4+1/8=3+3/8              11.011       3.1875


p111
2.46:

用二进制表示1/10只能用近似表示，值为0.00110011[0011]...，后面的[0011]会无限重复。

用小数点后面的23个位来近似，x=0.1可表示为如下：
x=0.0011001100110011001100

A. 计算0.1-x=
  0.00110011001100110011[0011]...
- 0.0011001100110011001100
= 0.00000000000000000000000[1100]...

B. 0.1-x的近似值为多少？
 0.00000000000000000000000[1100]... = 1/pow(2,24)+1/pow(2,25) + 1/pow(2,28)+1/pow(2,29)+.. ~ 5.960464477539063e-08

C. 每0.1秒的误差上B题的值， 100小时=100*60*60*10=3600000个0.1秒，与B题的结果相乘
 误差约为0.21457672119140625

D. 如果导弹的速度为2000m/s, 则此时的误差为C题的值乘以2000约为429米。


p117
2.47:

IEEE 浮点数的表示， 例如倍数w=1+k+n, 其中最高位是符号位s，中间k位是指数Exponent位组e， 最后n位是小数Fraction位组f：
浮点数的值分3种情况：
一、Nomanized 情况，即指数位组非全0也非全1，用于表示大数字，此时：
    1. 符号位的值S = pow(-1, s)
    2. 指数位组的值E 以偏移量表达式表示，对于指数位组为k位的情况，偏移量Bias=pow(2,k-1)-1, 而指数位组的值E 为指数位组表示的无符号数-偏移量。
    3. 小数位组的值为M = 1.[f<n-1>...f<0>]
    整个浮点数的值= S * M * pow( 2, E )
二、Denomanized 情况，即指数位组是全0时，用于表示趋于0的数字, 此时：
    1. 符号位的值S = pow(-1, s)
    2. 指数位组的值E 以偏移量表达式表示，对于指数位组为k位的情况，偏移量Bias=pow(2,k-1)-1, 而指数位组的值E = 1-Bias, 这里E != -Bias是为了第一种和第二种值之间能连续。
    3. 小数位组的值为M = 0.[f<n-1>...f<0>]
    整个浮点数的值= S * M * pow( 2, E )
三、特殊值的情况，即指数位组是全1时，此时：
    1. 如果小数位组为全0,即表示无穷大，
    2. 如果小数位组不是全0,即表示NaN

这种表示法表示的数字是递增排列的：
例如，对于符号位为0时，即都正数时，
指数位组的值为全0, 比较是[0,1)之前的小数，是递增的。
对于指数位组值为1, 小数位组为全0时，表示数字1.0
对于指数位组值非全0, 表示较大的数，也是递增的。


因此，对于w=5, k=2,n=1的浮点数，
偏移量Bias=pow(2,k-1)-1=1
e为指数位组的无称号符号值
E 的值为 e与偏移量的表达式
pow(2,E)是指数值
f是小数部分位组表示的值
M是小数部分的实际值
V是分数表示的值

全部值如下：

               Exponent       Fraction          Value        
           ----------------   --------  ------------------------------
Bits       e   E   pow(2,E)    f   M    pow(2,E)*M     V     Decimal
--------  --- ---- --------  ---- ----  ----------  ------  ----------
表达示     0  1-B             0.f  0.f
0 00 00    0   0     1        0    0       0          0      0.0 
0 00 01    0   0     1        1/4  1/4     1/4        1/4    0.25 
0 00 10    0   0     1        2/4  2/4     2/4        1/2    0.5
0 00 11    0   0     1        3/4  3/4     3/4        3/4    0.75
表达式     U  U-B             0.f  1.f
0 01 00    1   0     1        0    1       1          1      1 
0 01 01    1   0     1        1/4  5/4     5/4        5/4    1.25
0 01 10    1   0     1        2/4  6/4     6/4        3/2     1.5
0 01 11    1   0     1        3/4  7/4     7/4        7/4     1.75
0 10 00    2   1     2        0    1       2          2       2.0
0 10 01    2   1     2        1/4  5/4     10/4       5/2     2.5
0 10 10    2   1     2        2/4  6/4     12/4       3       3.0
0 10 11    2   1     2        3/4  7/4     14/4       7/2     3.5

0 11 00                                                      +无穷大  
0 11 01                                                      NaN
0 11 10                                                      NaN
0 11 11                                                      NaN


p119
2.48:
整数3510593的十六进制表示为0x00359141
单精度浮点数3510593.0的十六进制表示为0x4a564504, 则这两个数的关系。

float为32位，其中指数部分为8位，小数部分为23位。偏移量Bias=pow(2,8-1)-1=127

3510593   = 0000 0000 0011 0101 1001 0001 0100 0001
3510593.0 = 0100 1010 0101 0110 0100 0101 0000 0100

3510593   = 0000 0000 001.1 0101 1001 0001 0100 0001 * pow(2,21)
去除最高位的1, 小数部分最后加2个0达到23个，则小数部分为1 0101 1001 0001 0100 0001 00
指数部分 U-127=21, 则u=148=128+16+4= 1001 0100
符号位为0
则转成实数后为：   [0] [1001 0100] [1 0101 1001 0001 0100 0001 00]
                 = 0100 1010 0101 0110 0100 0101 0000 0100


p120
2.49:
    对于小数部分为n位，指数有k位的实数，最小不能表示的整数，应该是：
    A. 其二进制表示为1, 后面有n 个 0, 再后面是 1, 即值为 pow(2,n+1) + 1
    B: 对于 n=23, k=8的单精度浮点数来说，pow(2,24)+1=16777217


p121
2.50:

浮点数的取近似值，一般用 Round-To-Even的方法，分4种情况：
  1. 即后面的值不到一半时舍去，
  2. 多于一半时进1, 
  3. 刚好在一半时，如果要求最低有效们为偶数，即为0, 也就是说，说明最低有效位目前是0，即舍去后面的数字。
  4. 刚好在一半时，如果最低有效位为1,则进1,使得最低有效位为0

因此，下面的各题，保存一位小数，答案如下：

 原二进制    原值十进制   符合条件   近似值    近似十进制
----------- ------------  --------  ---------  ----------
A. 10.010    2.25          3         10.0        2 
B. 10.011    2.375         2         10.1        2.5
C. 10.110    2.75          4         11.0        3
D. 11.001    3.125         1         11.0        3


p122
2.51

在2.46题中，由于0.1不能准确表示，而出现导弹事故。 ??
如果0.1用IEEE浮点数表示，k=8, n=23,
A. 则二进制表达式为:
    Bias=pow(2,8-1)-1=127
    0.1 = 1.0*

    4: 0.0625
    5: 0.03125   4:5=0.09375
    8: 0.00390625
    9: 0.001953125 4:5:8:9=0.099609375

原来的值= 0.00011001100110011001100=1.1001100110011001100*pow(2,-4)

e-127=-4, e=123=[01111011]
f=0.10011001100110011001100 [1100]... ([1100]部分不断重复)
用Round-to-Even法取值，则f= 0.100110011001100110011001101 (后面部分过半进1）
整个浮点数表示为 [0] [01111011] [100110011001100110011001101]

B. x用浮点数表示时与0.1的误差x-0.1= [0] [01111011] [100110011001100110011001101] - 0.1 = 1.[100110011001100110011001101] * pow(2, -4) - 0.1
    = 0.10000000009313226 - 0.1 =  0.00000000009313226

C. 100小时的时间误差， 100h=100*60*60*10=3600000个误差= 3600000* 0.00000000009313226=0.000335276136 秒
D. 100小时的距离误差， 速度为2000/s, 则为 2000 * 0.000335276136 = 0.670552272 米

p122
2.52:

对于7位表示的两种IEEE小点数，
A: k=3, n=4, Bias=3
B: k=4, n=3, Bias=7

找出与A的值最相近的B的值

     Format A                                      Format B
--------------------------------    ---------------------------------------------------------------------------------
  Bits    Value                       Bits    Value                     Comments
--------  -----------------------   --------  ------------------------  ---------------------------------------------
011 0000  1                         0111 000  1
101 1110  pow(2,2)*(1+14/16)=15/2   1001 111  pow(2,2)*(1+14/16)=15/2   e-7=2->e=9=[1001]
010 1001  pow(2,-1)*(1+9/16)=25/32  0110 100  pow(2,-1)*(1+8/16)=24/32  e-7=-1->e=6=[0110], 0.1001->0.100(在半但已为偶）
110 1111  pow(2,3)*(1+15/16)=31/2   1011 000  pow(2,4)*(1)=32/2         e-7=3->e=10=[1010], 0.1111->2.000, 即e再+1
000 0001  pow(2,-2)*(0+1/16)=1/64   0011 000  pow(2,-4)*(1)=1/64        e-7=-4->e=3=[0011]


p124
浮点数：
  符合：
    1. 加法交换律：a+b=b+a
    2. 乘法交换律：a*b=b*a
    3. 加法传递律: a>=b, 则a+x>=b+x
    4. 乘法传递律：a>=b, 则x>=0时，a*x>=b*x;当x<0时， a*x <=b*x
    5. a*a >= 0
  不符合：
    1. 加法结合律：a+b+c != a+(b+c)
    2. 乘法分配律：a*(b+c) != a*b + a*c

整数：
  符合：
    1. 加法交换律： a+b=b+a
    2. 加法结合律: a+b+c=a+(b+c)
    3. 分配律： a*(b+c)=a*b + a*c
  不符合：
    1. 加法传递律： a>=b, 不一定 a+x >= b+x
    2. 乘法传递律: a>=b, x>=0 不一定 a*x >= b*x; x<=时， 不一定 a*x <= b*x
    3. 不一定 a*a >= 0

p125
2.53:

定义双精度double型的两个特殊值
double最大的正数是 1.8e308, 即[0][1..10][1..1], 

则 可假设 1e400 会溢出为无穷大：
#define POS_INFINITY = 1e400
#define NEG_INFINITY = (-POS_INFINITY)
#define NEG_ZERO = (-1.0/POS_INFINITY)

p125
2.54:
int->float: 不溢出，但会变近似值
int,float->double, 安全
double->float, 会溢出，会变近似值
float,double->int, 会溢出， 会变近似值（趋向0,如1.9->1, -1.9->-1), 同时，不能找到合理表示的值会用Tmin表示，如(int)1e10->-21483648, 正数变负数

因此，对于x,f,d分别对应类型int, float, double, 下面的表达式是否都为真：
A. x == (int)(double) x, True，因为 double 比 int 精度高
B. x == (int)(float) x, False, 如 x=Tmax时。
C. d == (double)(float) d, False, 当 d=1e40时。
D. f == (float)(double) f True.
E. f == -(-f) ， True, float 的正负数转换只改变符号位即可。
F. 1.0/2 == 1/2.0 True, 左右的各操作数都会先转成 float
G. d*d >= 0.0, True, 但有可能会出现无穷大
H. (f+d)-f == d False, 当 f=1e20, d=1时， f+d会近似为 f, 那么左边为 0, 右边为d=1.0
