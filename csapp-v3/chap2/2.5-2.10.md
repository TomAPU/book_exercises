p48
2.5:

字节序byte ordering分小数端little endian和大数端big endian.
Intel芯片一般用little endian, Android/IOS系统也用little endian
0x01234567从低地址到高地址的表示:
    little endian: 67 45 23 01 即最低有效字节在低地址处
    big endian: 01 23 45 67, 更符合日常写法
12345 的 十六进制数为 0x3039

因此:
int val = 0x87654321;
byte_pointer valp = (byte_pointef) &val;
show_bytes(valp, 1); /*A. */
show_bytes(valp, 2); /* B. */
show_bytes(valp, 3); /* C. */

Little endian: 
    A. 21,   B. 21 43,  C. 21 43 65
Big endian: 
    A. 87,   B. 87 65,  C. 87 65 43


p49
2.6:
int 3510593 = 0x00359141, 即
001101011001000101000001
float 3510593.0 = 0x4A564504, 即
01001010010101100100010100000100

B.
int  :       00000000001101011001000101000001
float:         01001010010101100100010100000100
一共有21个位匹配

C.
    |<--11-->|<------21------>|
       |<-9->|<------21------>|<-2->|



p49
2.7:
ASCII中的数字x对应整数0x30+x, 0-9, 对应0x30-0x39
ASCII中的字符a-z, 对应0x61~0x7A
ASCII中的字符A-Z, 对应0x41~0x5A

因此
const char *s = "abcdef";
show_bytes((byte_pointer) s, strlen(s));
输出为 61 62 63 64 65 66


p51
2.8:
Operation   Result
a           01101001
b           01010101
~a          10010110
~b          10101010
a&b         01000001
a|b         01111101
a^b         00111100


p53
2.9:
bit vector可以映射finite set,
如 [01101001] --> {0, 3, 5, 6 } 即第0,3,5,6位为1(最右边位为第0位)
   [01010101] --> {0, 2, 4, 6} 即第0,2,4,6位为1(最右边位为第0位)

   映射后, bit vector的& --> finite set 的交集
           bit vector的| --> finite set 的并集

    color RGB的bit vector [RGB]
    A. bit vector里的每一位取反
    B. :
        Blue | Green = [001] | [010] = [011] = Cyan
        Yellow & Cyan = [110] & [011] = [010] = Green
        Red ^ Magenta = [100] ^ [101] = [001] = Black


p54
2.10
利用a^a=0实现:
void inplace_swap( int *x, int *y)
{
    *y = *x ^ *y; /* step 1 */
    *x = *x ^ *y; /* step 2 */
    *y = *x ^ *y; /* step 3 */
}

step    *x          *y    
Init    a           b
step1   a           a^b
step2   a^a^b=b     a^b
step3   b           b^a^b=a


