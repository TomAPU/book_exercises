p58
2.16:

右移位分逻辑移位和算术移位，
但C语言标准中没有规定，一般编译器的实现是：signed int : arithmetical shift
   unsigned int: logical shift
JAVA中， >> 是arithmetical, >>>是 logical

x=0xC3 = 1100 0011; x<<3 = 0001 1000= 0x18; x>>2(logical)=0011 0000=0x30; x>>2(arithmetic)=1111 0000=0xF0
x=0x75 = 0111 0101; x<<3 = 1010 1000= 0xA8; x>>2(logical)=0001 1101=0x1D; x>>2(arithmetic)=0001 1101=0x1D
x=0x87 = 1000 0111; x<<3 = 0011 1000= 0x38; x>>2(logical)=0010 0001=0x21; x>>2(arithmetic)=1110 0001=0xE1
x=0x66 = 0110 0110; x<<3 = 0011 0000= 0x30; x>>2(logical)=0001 1001=0x19; x>>2(arithmetic)=0001 1001=0x19

p66
2.17:
    0xE = [1110]; B2U: pow(2,3) + pow(2,2) + pow(2,1) = 8+4+2=14; B2T: -pow(2,3)+pow(2,2)+pow(2,1)=-8+4+2=-2
    0x0 = [0000]; B2U: =0; B2T: =0
    0x5 = [0101]; B2U: pow(2,2) + pow(2,0) = 4+1=5; B2T: pow(2,2) + pow(2,0)=5
    0x8 = [1000]; B2U: pow(2,3) = 8; B2T: -pow(2,3)=-8
    0xD = [1101]; B2U: pow(2,3) + pow(2,2) + pow(2,0) = 8+4+1=13; B2T: -pow(2,3)+pow(2,2)+pow(2,0)=-8+4+1=-3
    0xF = [1111]; B2U: pow(2,3) + pow(2,2) + pow(2,1) +pow(2,0) = 8+4+2+1=15; B2T: -pow(2,3)+pow(2,2)+pow(2,1)+pow(2,0)=-8+4+2+1=-1


p69
2.18:

w位二进制转无符号数 B2U时，最小值U<min>=0, 最大值U<max>=pow(2, w) -1
w位二进制转二进制补码表示的有符号数时 B2T，最小值T<min>=-pow(2, w-1), 最大值T<max>=pow(2, w-1)-1
U<max> = 2T<max> + 1

二进制补码的属性：当x为非负数时，-x=pow(2,w)-x，即-x是x的补码，即将x取反加1就等到-x。

C99的<stdint.h>中定义的各种固定倍数的整型，如unit16_t, int32_t, 在printf是要用相应的宏表示输出类型：
如当x为int32_t, y为unit64_t是。
printf( "x=%" PRId32 ", y=%" PRIu64 "\n", x, y ), 再由C语言的字符串自动拼接来完成。

该题？？
