p122
2.51

在2.46题中，由于0.1不能准确表示，而出现导弹事故。
如果0.1用IEEE浮点数表示，k=8, n=23,
A. 则二进制表达式为:
    Bias=pow(2,8-1)-1=127
    0.1 = 1.0*

    4: 0.0625
    5: 0.03125   4:5=0.09375
    8: 0.00390625
    9: 0.001953125 4:5:8:9=0.099609375

原来的值= 0.00011001100110011001100=1.1001100110011001100*pow(2,-4)

e-127=-4, e=123=[01111011]
f=0.10011001100110011001100 [1100]... ([1100]部分不断重复)
用Round-to-Even法取值，则f= 0.100110011001100110011001101 (后面部分过半进1）
整个浮点数表示为 [0] [01111011] [100110011001100110011001101]

B. x用浮点数表示时与0.1的误差x-0.1= [0] [01111011] [100110011001100110011001101] - 0.1 = 1.[100110011001100110011001101] * pow(2, -4) - 0.1
    = 0.10000000009313226 - 0.1 =  0.00000000009313226

C. 100小时的时间误差， 100h=100*60*60*10=3600000个误差= 3600000* 0.00000000009313226=0.000335276136 秒
D. 100小时的距离误差， 速度为2000/s, 则为 2000 * 0.000335276136 = 0.670552272 米

p122
2.52:

对于7位表示的两种IEEE小点数，
A: k=3, n=4, Bias=3
B: k=4, n=3, Bias=7

找出与A的值最相近的B的值

     Format A                                      Format B
--------------------------------    ---------------------------------------------------------------------------------
  Bits    Value                       Bits    Value                     Comments
--------  -----------------------   --------  ------------------------  ---------------------------------------------
011 0000  1                         0111 000  1
101 1110  pow(2,2)*(1+14/16)=15/2   1001 111  pow(2,2)*(1+14/16)=15/2   e-7=2->e=9=[1001]
010 1001  pow(2,-1)*(1+9/16)=25/32  0110 100  pow(2,-1)*(1+8/16)=24/32  e-7=-1->e=6=[0110], 0.1001->0.100(在半但已为偶）
110 1111  pow(2,3)*(1+15/16)=31/2   1011 000  pow(2,4)*(1)=32/2         e-7=3->e=10=[1010], 0.1111->2.000, 即e再+1
000 0001  pow(2,-2)*(0+1/16)=1/64   0011 000  pow(2,-4)*(1)=1/64        e-7=-4->e=3=[0011]


p124
浮点数：
  符合：
    1. 加法交换律：a+b=b+a
    2. 乘法交换律：a*b=b*a
    3. 加法传递律: a>=b, 则a+x>=b+x
    4. 乘法传递律：a>=b, 则x>=0时，a*x>=b*x;当x<0时， a*x <=b*x
    5. a*a >= 0
  不符合：
    1. 加法结合律：a+b+c != a+(b+c)
    2. 乘法分配律：a*(b+c) != a*b + a*c

整数：
  符合：
    1. 加法交换律： a+b=b+a
    2. 加法结合律: a+b+c=a+(b+c)
    3. 分配律： a*(b+c)=a*b + a*c
  不符合：
    1. 加法传递律： a>=b, 不一定 a+x >= b+x
    2. 乘法传递律: a>=b, x>=0 不一定 a*x >= b*x; x<=时， 不一定 a*x <= b*x
    3. 不一定 a*a >= 0

p125
2.53:

定义双精度double型的两个特殊值
double最大的正数是 1.8e308, 即[0][1..10][1..1], 

则：
#define POS_INFINITY = (1.8e308+1) = [0][1..1][0..0]
#define NEG_INFINITY = (-(1.8e308-1)) = [1][1..1][0..0]
#define NEG_ZERO = [1][0..0]

p125
2.54:
int->float: 不溢出，但会变近似值
int,float->double, 安全
double->float, 会溢出，会变近似值
float,double->int, 会溢出， 会变近似值（趋向0,如1.9->1, -1.9->-1), 同时，不能找到合理表示的值会用Tmin表示，如(int)1e10->-21483648, 正数变负数

因此，对于x,f,d分别对应类型int, float, double, 下面的表达式是否都为真：
A. x == (int)(double) x
B. x == (int)(float) x
C. d == (double)(float) d
D. f == (float)(double) f
E. f == -(-f)
F. 1.0/2 == 1/2.0
G. d*d >= 0.0
H. (f+d)-f == d
