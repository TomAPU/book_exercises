p107
2.43:

对于整数x乘以常数M, 如果M=[(0..0)(1..1)(0..0)(1..1)(0..0)..],
对于每一组(1..1), 如果最高位为n, 最低位为m,
则x与这组1相乘的结果为
A: x<<m + x<<(m+1) + ... + x<<n;
也可以表示为
B: x<<(n+1)-x<<m

对于整数y除以一个常数N=pow(2,k), 
如果y>=0, 则值为 y>>k;
如果y<0, 则值为 (y + (1<<k)-1)>>k;

因此，对于 result = x*M + y/N;这条语句，
由编译器优化后生成的汇编代码再转成的C代码如下：
int t = x;
x <<= 5;
x -= t;
if (y<0) y += 7;
y >>= 3;

可以看出，x*M转变成了 x<<5 - x<<0, 故n+1=5, n=4, M=[11111] = 31
k=3, N = pow(2,3)=8

p108
2.44:

假设int为32为补码型整数，有符号数右移是算术右移，无符号数右移是逻辑右移。

其中:
int x = foo();
int y = bar();
unsigned ux = x;
unsigned uy = y;
对于以下的各表达式，回答两个问题：(1)对于任意的x和y值，该表达式是否为true,
(2) 当x和y取什么值时为false

A. (x > 0) || (x-1 < 0)
　　右边为真的条件是x<1, 与左边的条件是相交的，故无论x为何值，表达式都为真
B. (x & 7) != 7 || (x<<29 < 0)
   左边的要求x的最低3位不能全部为1, 右边的要求第3位为1; 当x的第3位为1时，右边为真，故表达式为真；当x的第3位为0时，右边为假，但符合左边的要求（最低3位不能全部为1），故无论x为何值，表达式都为真
C. (x * x) >= 0
   由于是固定倍数，会有溢出的情况，会有正数乘以正数结果为负数的情况，故某些条件下 (x*x)<0, 例如：当x=pow(2,16)-1时，x*x=pow(2,32)+1-pow(2,17), 在32位
   的补码表示时，pow(2,32)溢出，-pow(2,17)可以用pow(2,17)取反+1获取，此时x*x的值中最高位为1,为负数。
D. x<O || -x <= 0
    x=0时显然成立;左边要求x的最高位为1;右边-x<0,即x取反+1后最高位为1, 由于左边要求最高位为1,现在只考虑右边最高位为0，此时取反+1后最高位都为1, 或者00..0取反+1后为0也符合;因此结果都为真
E. x>O || -x >= 0
    x=0显示成立; 左边要求x产最高位为0; 右边-x>0, 即要求x取反+1后最高位为0, 由于左边要求最高位为0, 现只考虑右边最高位为1, 但是对于x=[100..00], 取反+1后为[011..11]+1=[100..00]<0, 此时为假。
F. x+y == uy+ux
    表达式中含无符号数，所以左边也要转成无符号数。 在二进制上，无符号数和有符号数的加法是一样的，故都为真。
G. x*~y + uy*ux == -x
    -y = ~y+1,故 ~y=-y-1, 左边= x*(-y-1)+uy*ux = uy*ux - x*y -x, 不管是无符号数还是有符号数，在二进制层面上相乘后截短后的结果都是相同的。故 uy*ux-x*y=0, 故结果都为真
