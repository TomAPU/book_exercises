p107
2.43:

对于整数x乘以常数M, 如果M=[(0..0)(1..1)(0..0)(1..1)(0..0)..],
对于每一组(1..1), 如果最高位为n, 最低位为m,
则x与这组1相乘的结果为
A: x<<m + x<<(m+1) + ... + x<<n;
也可以表示为
B: x<<(n+1)-x<<m

对于整数y除以一个常数N=pow(2,k), 
如果y>=0, 则值为 y>>k;
如果y<0, 则值为 (y + (1<<k)-1)>>k;

因此，对于 result = x*M + y/N;这条语句，
由编译器优化后生成的汇编代码再转成的C代码如下：
int t = x;
x <<= 5;
x -= t;
if (y<0) y += 7;
y >>= 3;

可以看出，x*M转变成了 x<<5 - x<<0, 故n+1=5, n=4, M=[11111] = 31
k=3, N = pow(2,3)=8

p108
2.44:

假设int为32为补码型整数，有符号数右移是算术右移，无符号数右移是逻辑右移。

其中:
int x = foo();
int y = bar();
unsigned ux = x;
unsigned uy = y;
对于以下的各表达式，回答两个问题：(1)对于任意的x和y值，该表达式是否为true,
(2) 当x和y取什么值时为false

A. (x > 0) || (x-1 < 0)
　　右边为真的条件是x<1, 与左边的条件是相交的，故无论x为何值，表达式都为真
B. (x & 7) != 7 || (x<<29 < 0)
   左边的要求x的最低3位不能全部为1, 右边的要求第3位为1; 当x的第3位为1时，右边为真，故表达式为真；当x的第3位为0时，右边为假，但符合左边的要求（最低3位不能全部为1），故无论x为何值，表达式都为真
C. (x * x) >= 0
   由于是固定倍数，会有溢出的情况，会有正数乘以正数结果为负数的情况，故某些条件下 (x*x)<0, 例如：当x=pow(2,16)-1时，x*x=pow(2,32)+1-pow(2,17), 在32位
   的补码表示时，pow(2,32)溢出，-pow(2,17)可以用pow(2,17)取反+1获取，此时x*x的值中最高位为1,为负数。
D. x<O || -x <= 0
    x=0时显然成立;左边要求x的最高位为1;右边-x<0,即x取反+1后最高位为1, 由于左边要求最高位为1,现在只考虑右边最高位为0，此时取反+1后最高位都为1, 或者00..0取反+1后为0也符合;因此结果都为真
E. x>O || -x >= 0
    x=0显示成立; 左边要求x产最高位为0; 右边-x>0, 即要求x取反+1后最高位为0, 由于左边要求最高位为0, 现只考虑右边最高位为1, 但是对于x=[100..00], 取反+1后为[011..11]+1=[100..00]<0, 此时为假。
F. x+y == uy+ux
    表达式中含无符号数，所以左边也要转成无符号数。 在二进制上，无符号数和有符号数的加法是一样的，故都为真。
G. x*~y + uy*ux == -x
    -y = ~y+1,故 ~y=-y-1, 左边= x*(-y-1)+uy*ux = uy*ux - x*y -x, 不管是无符号数还是有符号数，在二进制层面上相乘后截短后的结果都是相同的。故 uy*ux-x*y=0, 故结果都为真


p111
2.45:

分数的二进制表示：

0.1=1/2=0.5  0.01=1/4=0.25  0.001=1/8=0.125  0.0001=1/16=0.0625  0.00001=1/32=0.03125

因此：

分数                       二进制值      十进制值
------                    ----------   ------------
1/8                          0.001        0.0125
3/4=1/4+1/2                  0.11         0.75
5/16=1/4+1/16                0.0101       0.3125
2+1/2+1/8+1/16=2+11/16       10.1011      2.6875
1+1/8                        1.001        1.125
5+1/2+1/4+1/8=5+7/8          101.111      5.875
3+1/4+1/8=3+3/8              11.011       3.1875


p111
2.46:

用二进制表示1/10只能用近似表示，值为0.00110011[0011]...，后面的[0011]会无限重复。

用小数点后面的23个位来近似给，x=0.1可表示为如下：
x=0.00011001100110011001100

A. 计算0.1-x=
  0.000110011001100110011[0011]...
- 0.00011001100110011001100
= 0.0000000000000000000000011[0011]...

B. 0.1-x的近似值为多少？
 0.0000000000000000000000011[0011]... = 1/pow(2,24)+1/pow(2,25) + 1/pow(2,28)+1/pow(2,29)+.. ~ 5.960464477539063e-08

C. 每0.1秒的误差上B题的值， 100小时=100*60*60*10=3600000个0.1秒，与B题的结果相乘
 误差约为0.21457672119140625

D. 如果导弹的速度为2000m/s, 则此时的误差为C题的值乘以2000约为429米。


p117
2.47:

IEEE 浮点数的表示， 例如倍数w=1+k+n, 其中最高位是符号位s，中间k位是指数Exponent位组e， 最后n位是小数Fraction位组f：
浮点数的值分3种情况：
一、Nomanized 情况，即指数位组非全0也非全1，用于表示大数字，此时：
    1. 符号位的值S = pow(-1, s)
    2. 指数位组的值E 以偏移量表达式表示，对于指数位组为k位的情况，偏移量Bias=pow(2,k-1)-1, 而指数位组的值E 为指数位组表示的无符号数-偏移量。
    3. 小数位组的值为M = 1.[f<n-1>...f<0>]
    整个浮点数的值= S * M * pow( 2, E )
二、Denomanized 情况，即指数位组是全0时，用于表示趋于0的数字, 此时：
    1. 符号位的值S = pow(-1, s)
    2. 指数位组的值E 以偏移量表达式表示，对于指数位组为k位的情况，偏移量Bias=pow(2,k-1)-1, 而指数位组的值E = 1-Bias, 这里E != -Bias是为了第一种和第二种值之间能连续。
    3. 小数位组的值为M = 0.[f<n-1>...f<0>]
    整个浮点数的值= S * M * pow( 2, E )
三、特殊值的情况，即指数位组是全1时，此时：
    1. 如果小数位组为全0,即表示无穷大，
    2. 如果小数位组为是全0,即表示NaN

因此，对于w=5, k=2,n=1的浮点数，
偏移量Bias=pow(2,k-1)-1=1
e为指数位组的无称号符号值
E 的值为 e与偏移量的表达式
pow(2,E)是指数值
f是小数部分位组表示的值
M是小数部分的实际值
V是分数表示的值

全部值如下：

               Exponent       Fraction          Value        
           ----------------   --------  ------------------------------
Bits       e   E   pow(2,E)    f   M    pow(2,E)*M     V     Decimal
--------  --- ---- --------  ---- ----  ----------  ------  ----------
表达示     0  1-B             0.f  0.f
0 00 00    0   0     1        0    0       0          0      0.0 
0 00 01    0   0     1        1/4  1/4     1/4        1/4    0.25 
0 00 10    0   0     1        2/4  2/4     2/4        1/2    0.5
0 00 11    0   0     1        3/4  3/4     3/4        3/4    0.75
表达式     U  U-B             0.f  1.f
0 01 00    1   0     1        0    1       1          1      1 
0 01 01    1   0     1        1/4  5/4     5/4        5/4    1.25
0 01 10    1   0     1        2/4  6/4     6/4        3/2     1.5
0 01 11    1   0     1        3/4  7/4     7/4        7/4     1.75
0 10 00    2   1     2        0    1       2          2       2.0
0 10 01    2   1     2        1/4  5/4     10/4       5/2     2.5
0 10 10    2   1     2        2/4  6/4     12/4       3       3.0
0 10 11    2   1     2        3/4  7/4     14/4       7/2     3.5

0 11 00                                                      +无穷大  
0 11 01                                                      NaN
0 11 10                                                      NaN
0 11 11                                                      NaN


p119
2.48:
整数3510593的十六进制表示为0x00359141
单精度浮点数3510593.0的十六进制表示为0x4a564504, 则这两个数的关系。

float为32位，其中指数部分为8位，小数部分为23位。偏移量Bias=pow(2,8-1)-1=127

3510593   = 0000 0000 0011 0101 1001 0001 0100 0001
3510593.0 = 0100 1010 0101 0110 0100 0101 0000 0100

3510593   = 0000 0000 001.1 0101 1001 0001 0100 0001 * pow(2,21)
去除最高位的1, 小数部分最后加2个0达到23个，则小数部分为1 0101 1001 0001 0100 0001 00
指数部分 U-127=21, 则u=148=128+16+4= 1001 0100
符号位为0
则转成实数后为：   [0] [1001 0100] [1 0101 1001 0001 0100 0001 00]
                 = 0100 1010 0101 0110 0100 0101 0000 0100


p120
2.49:
    对于小数部分为n位，指数有k位的实数，最小不能表示的正数，应该是：
    指数值M=1-( pow(2,k-1)-1) = 2-pow(2, k-1)
    小数部分要n+1位，即 1/pow(2, n+1)

    最小不能表示的正数为： ( 1/pow(2, n+1) ) * pow(2, 2-pow(2,k-1))

    B: 对于 n=23, k=8的单精度浮点数来说，这个值为 ( 1/pow(2,24) ) * pow(2, 2-127) = 1/pow(2,149)=1.401298464324817e-45


p121
2.50:

浮点数的取近似值，一般用 Round-To-Even的方法，分4种情况：
  1. 即后面的值不到一半时舍去，
  2. 多于一半时进1, 
  3. 刚好在一半时，如果要求最低有效们为偶数，即为0, 也就是说，说明最低有效位目前是0，即舍去后面的数字。
  4. 刚好在一半时，如果最低有效位为1,则进1,使得最低有效位为0

因此，下面的各题，保存一位小数，答案如下：

 原二进制    原值十进制   符合条件   近似值    近似十进制
----------- ------------  --------  ---------  ----------
A. 10.010    2.25          3         10.0        2 
B. 10.011    2.375         2         10.1        2.5
C. 10.110    2.75          4         11.0        3
D. 11.001    3.125         1         11.0        3


p122
2.51

在2.46题中，由于0.1不能准确表示，而出现导弹事故。
如果0.1用IEEE浮点数表示，k=8, n=23,
A. 则二进制表达式为:
    Bias=pow(2,8-1)-1=127
    0.1 = 1.0*

    4: 0.0625
    5: 0.03125   4:5=0.09375
    8: 0.00390625
    9: 0.001953125 4:5:8:9=0.099609375

原来的值= 0.00011001100110011001100=1.1001100110011001100*pow(2,-4)

e-127=-4, e=123=[01111011]
f=0.10011001100110011001100 [1100]... ([1100]部分不断重复)
用Round-to-Even法取值，则f= 0.100110011001100110011001101 (后面部分过半进1）
整个浮点数表示为 [0] [01111011] [100110011001100110011001101]

B. x用浮点数表示时与0.1的误差x-0.1= [0] [01111011] [100110011001100110011001101] - 0.1 = 1.[100110011001100110011001101] * pow(2, -4) - 0.1
    = 0.10000000009313226 - 0.1 =  0.00000000009313226

C. 100小时的时间误差， 100h=100*60*60*10=3600000个误差= 3600000* 0.00000000009313226=0.000335276136 秒
D. 100小时的距离误差， 速度为2000/s, 则为 2000 * 0.000335276136 = 0.670552272 米
