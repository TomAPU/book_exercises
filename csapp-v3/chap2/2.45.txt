p107
2.43:

对于整数x乘以常数M, 如果M=[(0..0)(1..1)(0..0)(1..1)(0..0)..],
对于每一组(1..1), 如果最高位为n, 最低位为m,
则x与这组1相乘的结果为
A: x<<m + x<<(m+1) + ... + x<<n;
也可以表示为
B: x<<(n+1)-x<<m

对于整数y除以一个常数N=pow(2,k), 
如果y>=0, 则值为 y>>k;
如果y<0, 则值为 (y + (1<<k)-1)>>k;

因此，对于 result = x*M + y/N;这条语句，
由编译器优化后生成的汇编代码再转成的C代码如下：
int t = x;
x <<= 5;
x -= t;
if (y<0) y += 7;
y >>= 3;

可以看出，x*M转变成了 x<<5 - x<<0, 故n+1=5, n=4, M=[11111] = 31
k=3, N = pow(2,3)=8

p108
2.44:

假设int为32为补码型整数，有符号数右移是算术右移，无符号数右移是逻辑右移。

其中:
int x = foo();
int y = bar();
unsigned ux = x;
unsigned uy = y;
对于以下的各表达式，回答两个问题：(1)对于任意的x和y值，该表达式是否为true,
(2) 当x和y取什么值时为false

A. (x > 0) || (x-1 < 0)
　　右边为真的条件是x<1, 与左边的条件是相交的，故无论x为何值，表达式都为真
B. (x & 7) != 7 || (x<<29 < 0)
   左边的要求x的最低3位不能全部为1, 右边的要求第3位为1; 当x的第3位为1时，右边为真，故表达式为真；当x的第3位为0时，右边为假，但符合左边的要求（最低3位不能全部为1），故无论x为何值，表达式都为真
C. (x * x) >= 0
   由于是固定倍数，会有溢出的情况，会有正数乘以正数结果为负数的情况，故某些条件下 (x*x)<0, 例如：当x=pow(2,16)-1时，x*x=pow(2,32)+1-pow(2,17), 在32位
   的补码表示时，pow(2,32)溢出，-pow(2,17)可以用pow(2,17)取反+1获取，此时x*x的值中最高位为1,为负数。
D. x<O || -x <= 0
    x=0时显然成立;左边要求x的最高位为1;右边-x<0,即x取反+1后最高位为1, 由于左边要求最高位为1,现在只考虑右边最高位为0，此时取反+1后最高位都为1, 或者00..0取反+1后为0也符合;因此结果都为真
E. x>O || -x >= 0
    x=0显示成立; 左边要求x产最高位为0; 右边-x>0, 即要求x取反+1后最高位为0, 由于左边要求最高位为0, 现只考虑右边最高位为1, 但是对于x=[100..00], 取反+1后为[011..11]+1=[100..00]<0, 此时为假。
F. x+y == uy+ux
    表达式中含无符号数，所以左边也要转成无符号数。 在二进制上，无符号数和有符号数的加法是一样的，故都为真。
G. x*~y + uy*ux == -x
    -y = ~y+1,故 ~y=-y-1, 左边= x*(-y-1)+uy*ux = uy*ux - x*y -x, 不管是无符号数还是有符号数，在二进制层面上相乘后截短后的结果都是相同的。故 uy*ux-x*y=0, 故结果都为真


p111
2.45:

分数的二进制表示：

0.1=1/2=0.5  0.01=1/4=0.25  0.001=1/8=0.125  0.0001=1/16=0.0625  0.00001=1/32=0.03125

因此：

分数                       二进制值      十进制值
------                    ----------   ------------
1/8                          0.001        0.0125
3/4=1/4+1/2                  0.11         0.75
5/16=1/4+1/16                0.0101       0.3125
2+1/2+1/8+1/16=2+11/16       10.1011      2.6875
1+1/8                        1.001        1.125
5+1/2+1/4+1/8=5+7/8          101.111      5.875
3+1/4+1/8=3+3/8              11.011       3.1875


p111
2.46:

用二进制表示1/10只能用近似表示，值为0.00110011[0011]...，后面的[0011]会无限重复。

用小数点后面的23个位来近似给，x=0.1可表示为如下：
x=0.00011001100110011001100

A. 计算0.1-x=
  0.000110011001100110011[0011]...
- 0.00011001100110011001100
= 0.0000000000000000000000011[0011]...

B. 0.1-x的近似值为多少？
 0.0000000000000000000000011[0011]... = 1/pow(2,24)+1/pow(2,25) + 1/pow(2,28)+1/pow(2,29)+.. ~ 5.960464477539063e-08

C. 每0.1秒的误差上B题的值， 100小时=100*60*60*10=3600000个0.1秒，与B题的结果相乘
 误差约为0.21457672119140625

D. 如果导弹的速度为2000m/s, 则此时的误差为C题的值乘以2000约为429米。
